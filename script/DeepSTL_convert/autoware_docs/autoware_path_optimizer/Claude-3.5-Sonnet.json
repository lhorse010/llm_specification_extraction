{
    "temporal_logic_formulars": [
        {
            "section-id": 1,
            "sentence-id": 1,
            "sentence": "1.make the trajectory inside the drivable area as much as possible",
            "tl": "always ( rise ( maketrajectory == drivableareamuchpossible ) -> m == possiblele )"
        },
        {
            "section-id": 1,
            "sentence-id": 3,
            "sentence": "2.insert stop point before the planned footprint will be outside the drivable area",
            "tl": "always ( not ( p2insertstop == planedfotprint ) -> not ( drivablearearea == earearea ) )"
        },
        {
            "section-id": 3,
            "sentence-id": 0,
            "sentence": "When one of the following conditions are met, trajectory optimization will be executed.",
            "tl": "always ( oneettra == jectopimization = executed )"
        },
        {
            "section-id": 3,
            "sentence-id": 3,
            "sentence": "1.Ego moves longer than replan.max_ego_moving_dist in one cycle. (default: 3.0 [m])",
            "tl": "always ( rEgomoveslongereplanger == replg_o_moving_dist = onecyclecyle ) until [ 0 : odist ) -> edefault >= 3.0 and edefaultl <= m )"
        },
        {
            "section-id": 3,
            "sentence-id": 5,
            "sentence": "2.Trajectory's end, which is considered as the goal pose, moves longer than replan.max_goal_moving_dist in one cycle. (default: 15.0 [ms])",
            "tl": "always ( not ( s2Trajectoreder == dgolasemovesloner ) ) until ( xmovesle == rmoleplnger ) -> mx_golin_dst >== onecyclgltefault15 . 0 and msdefault <= mefault15 . 0 )"
        },
        {
            "section-id": 3,
            "sentence-id": 7,
            "sentence": "3.Time passes. (default: 1.0 [s])",
            "tl": "always ( demepassese > 0 . d and defaseses <= efault >= 1.0 and sdefault <= s ) -> s )"
        },
        {
            "section-id": 3,
            "sentence-id": 9,
            "sentence": "4.The input path changes laterally longer than replan.max_path_shape_around_ego_lat_dist in one cycle. (default: 2.0)",
            "tl": "always ( rise ( einputpathlatlera == erlylonger ) and mx_path_ath_ == eo_ro_ego_laud_eo_lat_l ) -> tonecycldist == onefauleclt2 . 0 and default < 4.0 )"
        },
        {
            "section-id": 4,
            "sentence-id": 0,
            "sentence": "This module makes the trajectory kinematically-feasible and collision-free.",
            "tl": "always ( Thismodulemakes == trajectryineatical ) and ly == fellisionible )"
        },
        {
            "section-id": 4,
            "sentence-id": 2,
            "sentence": "This optimization considers vehicle kinematics and collision checking with road boundary and obstacles.",
            "tl": "always ( Thisoptimizatin == ocsiersieiclekinematics and colislinckin == itheckingwthrodo = ithrodadn )"
        },
        {
            "section-id": 4,
            "sentence-id": 3,
            "sentence": "To decrease the computation cost, the optimization is applied to the shorter trajectory (default: 50 [m]) than the whole trajectory, and concatenate the remained trajectory with the optimized one at last.",
            "tl": "always ( historically ( ocomputationcosti == tiatinapizioplied = shrtraetr ) -> ( wholetraect == traetecatetrjeoicetoicit == toieceoizth ) since ( rise ( whcerahlecatratoiece <= hotratratratecece ) )"
        },
        {
            "section-id": 4,
            "sentence-id": 5,
            "sentence": "Therefore, we use the previously generated trajectory in front of the ego.",
            "tl": "always ( ehereforewuese == previouslygenratedtrajectory == fronecetr )"
        },
        {
            "section-id": 5,
            "sentence-id": 0,
            "sentence": "Velocity is assigned in the optimized trajectory from the velocity in the behavior path.",
            "tl": "always ( Velocityassigned == optimizedtrajectory ) -> ryvelocity == behaviorpath )"
        },
        {
            "section-id": 6,
            "sentence-id": 1,
            "sentence": "Generated trajectory is checked if it is inside the drivable area or not, and if outside drivable area, output a trajectory inside drivable area with the behavior path or the previously generated trajectory.",
            "tl": "always ( not rise ( enratedtrajec == redcedtredco = itrdie ) and not ( drivalearea == ratreatrdautrde ) and datrea == ratrjedetrvcodaudervaleatrvaler ) -> ( ea == rialarvaleabeareawahavalereaheavheath == hrviodtredt"
        },
        {
            "section-id": 6,
            "sentence-id": 5,
            "sentence": "1.If optimized trajectory is inside the drivable area, and the remained trajectory is inside/outside the drivable area, the output trajectory will be just concatenation of those two trajectories.",
            "tl": "always ( rise ( optimizedtraje == rdaedctrydrei ) and not ( trajectry == drivajlectrearearearea ) and not ( dre == drotreatreatotrea ) -> ( ectotryjutrtr == tatocStnatonctetonetotSt == theosetorjetotetoricetorjetor"
        },
        {
            "section-id": 6,
            "sentence-id": 7,
            "sentence": "2.If optimized trajectory is outside the drivable area, and the remained trajectory is inside/outside the drivable area, and if the previously generated trajectory is memorized, the output trajectory will be the previously generated trajectory, where zero velocity is inserted to the point firstly going outside the drivable area; and if the previously generated trajectory is not memorized, the output trajectory will be a part of trajectory just transformed from the behavior path, where zero velocity is inserted to the point firstly going outside the drivable area.",
            "tl": "always ( not ( roptimizedtredtr == eajedtryecoredrjedtry ) and not ( drivajlectre == rydreareda = dre ) and trivajlectearea == eare ) and edreda == peredapeoleaeare )"
        },
        {
            "section-id": 6,
            "sentence-id": 9,
            "sentence": "The output trajectory is memorized as a previously generated trajectory for the next cycle.",
            "tl": "always ( outputrajector == memedaprviosedue )"
        },
        {
            "section-id": 16,
            "sentence-id": 0,
            "sentence": "option.enable_skip_optimization skips MPT optimization.",
            "tl": "always ( optionable_si == pizitionsinkipsMPToptimi == imizpt ) -> optimizi == izopiatimztiatioti == iatotimiotino )"
        },
        {
            "section-id": 16,
            "sentence-id": 1,
            "sentence": "option.enable_calculation_time_info enables showing each calculation time for functions and total calculation time on the terminal.",
            "tl": "always ( optionenabl_leca == lion_inesha ) until ( owgcles == howinlalculatin = ngl ) -> f == funcatunctitolcSlatinsonso )"
        },
        {
            "section-id": 16,
            "sentence-id": 2,
            "sentence": "option.enable_outside_drivable_area_stop enables stopping just before the generated trajectory point will be outside the drivable area.",
            "tl": "always ( not ( optioneable_od == i_derivale_r ) and enablstpena == gstpingjustpenerate ) -> not ( tgeneratedtr == dtrajeratedtrdr ) )"
        },
        {
            "section-id": 0,
            "sentence-id": 0,
            "sentence": "This package generates a trajectory that is kinematically-feasible to drive and collision-free based on the input path, drivable area.",
            "tl": "always ( eThispackagegenerate == atraectryicale ) and licasible == drlicoledeisionfredasedinp == ptahredasedaledahpt )"
        },
        {
            "section-id": 3,
            "sentence-id": 1,
            "sentence": "Otherwise, previously optimized trajectory is used with updating the velocity from the latest input path.",
            "tl": "always ( Otherwisepr == ioslyimiedtrjectoryused == edwithudatithup ) until ( Orded == dwgvelocitr ) -> elocitingvelocitylatyl == tetstinptestinputyputah )"
        },
        {
            "section-id": 4,
            "sentence-id": 4,
            "sentence": "The trajectory just in front of the ego must not be changed a lot so that the steering wheel will be stable.",
            "tl": "always ( not rise ( trajectoryjust == frontontego ) and steeringwhel == stelstablelele )"
        },
        {
            "section-id": 6,
            "sentence-id": 0,
            "sentence": "Optimized trajectory is too short for velocity planning, therefore extend the trajectory by concatenating the optimized trajectory and the behavior path considering drivability.",
            "tl": "always ( Opimizedtrajetr == tosorytosocitrelo == erefleninit ) or terefoe == trecendtetectenatene )"
        }
    ]
}