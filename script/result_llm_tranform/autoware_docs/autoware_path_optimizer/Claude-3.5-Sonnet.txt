[
  {
    "sentence": "1.make the trajectory inside the drivable area as much as possible",
    "formula": "G(D)",
    "explanation": "D represents the predicate 'trajectory is inside the drivable area'. The G (globally) operator ensures that this condition holds throughout the entire execution, capturing the 'as much as possible' aspect."
  },
  {
    "sentence": "2.insert stop point before the planned footprint will be outside the drivable area",
    "formula": "G(¬O → X(S))",
    "explanation": "O represents 'planned footprint is outside drivable area', and S represents 'stop point inserted'. This formula ensures that whenever the footprint is not outside (¬O), in the next state (X) a stop point is inserted (S), effectively preventing the footprint from leaving the drivable area."
  },
  {
    "sentence": "When one of the following conditions are met, trajectory optimization will be executed.",
    "formula": "G((C1 ∨ C2 ∨ C3 ∨ C4) → X(O))",
    "explanation": "C1, C2, C3, C4 represent the four conditions, and O represents 'trajectory optimization is executed'. This formula states that globally, if any of the conditions are met, in the next state, optimization will be executed."
  },
  {
    "sentence": "1.Ego moves longer than replan.max_ego_moving_dist in one cycle. (default: 3.0 [m])",
    "formula": "G(M → X(O))",
    "explanation": "M represents 'ego moves longer than max_ego_moving_dist', and O represents 'optimization is executed'. This captures the condition for triggering optimization based on ego movement."
  },
  {
    "sentence": "2.Trajectory's end, which is considered as the goal pose, moves longer than replan.max_goal_moving_dist in one cycle. (default: 15.0 [ms])",
    "formula": "G(G → X(O))",
    "explanation": "G represents 'goal pose moves longer than max_goal_moving_dist', and O represents 'optimization is executed'. This formula ensures optimization occurs when the goal pose moves significantly."
  },
  {
    "sentence": "3.Time passes. (default: 1.0 [s])",
    "formula": "G(F[1,1](T) → X(O))",
    "explanation": "T represents 'time has passed', and O is 'optimization is executed'. The F[1,1] operator specifies that within exactly 1 time unit, T becomes true, triggering optimization in the next state."
  },
  {
    "sentence": "4.The input path changes laterally longer than replan.max_path_shape_around_ego_lat_dist in one cycle. (default: 2.0)",
    "formula": "G(L → X(O))",
    "explanation": "L represents 'lateral path change exceeds max_path_shape_around_ego_lat_dist', and O is 'optimization is executed'. This formula ensures optimization occurs when significant lateral path changes are detected."
  },
  {
    "sentence": "This module makes the trajectory kinematically-feasible and collision-free.",
    "formula": "G(K ∧ F)",
    "explanation": "K represents 'trajectory is kinematically-feasible', and F represents 'trajectory is collision-free'. The G operator ensures these properties hold globally for the entire trajectory."
  },
  {
    "sentence": "This optimization considers vehicle kinematics and collision checking with road boundary and obstacles.",
    "formula": "G(O → (K ∧ C))",
    "explanation": "O represents 'optimization is performed', K is 'kinematics are considered', and C is 'collision checking is performed'. This formula states that whenever optimization occurs, both kinematics and collision checking are taken into account."
  },
  {
    "sentence": "To decrease the computation cost, the optimization is applied to the shorter trajectory (default: 50 [m]) than the whole trajectory, and concatenate the remained trajectory with the optimized one at last.",
    "formula": "G(O → (S ∧ F(R)))",
    "explanation": "O is 'optimization is performed', S is 'shorter trajectory is optimized', and R is 'remaining trajectory is concatenated'. This formula captures the process of optimizing a shorter segment and later concatenating the result with the remaining trajectory."
  },
  {
    "sentence": "Therefore, we use the previously generated trajectory in front of the ego.",
    "formula": "G(P → X(U))",
    "explanation": "P represents the presence of a previously generated trajectory, and U represents its usage. This formula states that globally, if a previous trajectory exists, in the next state it will be used."
  },
  {
    "sentence": "Velocity is assigned in the optimized trajectory from the velocity in the behavior path.",
    "formula": "G(B → O)",
    "explanation": "B represents the velocity in the behavior path, and O represents the assigned velocity in the optimized trajectory. This formula indicates that globally, the presence of velocity in the behavior path implies its assignment to the optimized trajectory."
  },
  {
    "sentence": "Generated trajectory is checked if it is inside the drivable area or not, and if outside drivable area, output a trajectory inside drivable area with the behavior path or the previously generated trajectory.",
    "formula": "G((G ∧ ¬D) → F(T ∧ D))",
    "explanation": "G represents the generated trajectory, D represents being inside the drivable area, and T represents the output trajectory. This formula states that globally, if a trajectory is generated and not in the drivable area, eventually a trajectory will be output that is inside the drivable area."
  },
  {
    "sentence": "1.If optimized trajectory is inside the drivable area, and the remained trajectory is inside/outside the drivable area, the output trajectory will be just concatenation of those two trajectories.",
    "formula": "G((O ∧ D) → X(C))",
    "explanation": "O represents the optimized trajectory, D represents being inside the drivable area, and C represents the concatenation of trajectories. This formula indicates that globally, if the optimized trajectory is inside the drivable area, in the next state, the trajectories will be concatenated."
  },
  {
    "sentence": "2.If optimized trajectory is outside the drivable area, and the remained trajectory is inside/outside the drivable area, and if the previously generated trajectory is memorized, the output trajectory will be the previously generated trajectory, where zero velocity is inserted to the point firstly going outside the drivable area; and if the previously generated trajectory is not memorized, the output trajectory will be a part of trajectory just transformed from the behavior path, where zero velocity is inserted to the point firstly going outside the drivable area.",
    "formula": "G((O ∧ ¬D) → ((M → P) ∧ (¬M → B)) ∧ F(Z))",
    "explanation": "O represents the optimized trajectory, D represents being inside the drivable area, M represents a memorized previous trajectory, P represents using the previous trajectory, B represents using the behavior path, and Z represents inserting zero velocity. This complex formula captures the different cases based on whether a previous trajectory is memorized or not, and ensures that zero velocity is eventually inserted."
  },
  {
    "sentence": "The output trajectory is memorized as a previously generated trajectory for the next cycle.",
    "formula": "G(T → X(M))",
    "explanation": "T represents the output trajectory, and M represents memorizing it. This formula states that globally, if an output trajectory is generated, in the next state (cycle) it will be memorized."
  },
  {
    "sentence": "option.enable_skip_optimization skips MPT optimization.",
    "formula": "G(E → ¬O)",
    "explanation": "E represents enabling the skip optimization option, and O represents performing MPT optimization. This formula indicates that globally, if the skip optimization option is enabled, MPT optimization will not be performed."
  },
  {
    "sentence": "option.enable_calculation_time_info enables showing each calculation time for functions and total calculation time on the terminal.",
    "formula": "G(C → F(S))",
    "explanation": "C represents enabling the calculation time info option, and S represents showing the calculation times. This formula states that globally, if the calculation time info option is enabled, eventually the calculation times will be shown."
  },
  {
    "sentence": "option.enable_outside_drivable_area_stop enables stopping just before the generated trajectory point will be outside the drivable area.",
    "formula": "G(A → G(¬D → X(S)))",
    "explanation": "A represents enabling the outside drivable area stop option, D represents being inside the drivable area, and S represents stopping. This formula indicates that globally, if the option is enabled, then globally, if a point is not in the drivable area, in the next state the system will stop."
  },
  {
    "sentence": "This package generates a trajectory that is kinematically-feasible to drive and collision-free based on the input path, drivable area.",
    "formula": "G(I → F(T ∧ K ∧ C))",
    "explanation": "I represents the input (path and drivable area), T represents generating a trajectory, K represents kinematic feasibility, and C represents being collision-free. This formula states that globally, given an input, eventually a trajectory will be generated that is both kinematically feasible and collision-free."
  },
  {
    "sentence": "Otherwise, previously optimized trajectory is used with updating the velocity from the latest input path.",
    "formula": "G(¬O → (P ∧ X(U)))",
    "explanation": "This formula states that globally (G), if optimization is not performed (¬O), then the previously optimized trajectory (P) is used, and in the next state (X), the velocity is updated (U). This captures the conditional nature of using the previous trajectory and the immediate update of velocity."
  },
  {
    "sentence": "The trajectory just in front of the ego must not be changed a lot so that the steering wheel will be stable.",
    "formula": "G(F ∧ X(¬C) ∧ X(X(¬C)) → S)",
    "explanation": "Here, F represents the trajectory in front of the ego, C represents a significant change, and S represents steering wheel stability. The formula states that globally (G), if the front trajectory (F) exists and doesn't change significantly in the next two time steps (X(¬C) ∧ X(X(¬C))), then the steering wheel remains stable (S). This captures the relationship between trajectory consistency and steering stability."
  },
  {
    "sentence": "Optimized trajectory is too short for velocity planning, therefore extend the trajectory by concatenating the optimized trajectory and the behavior path considering drivability.",
    "formula": "G(S → X(E ∧ (O U B)))",
    "explanation": "In this formula, S represents a short optimized trajectory, E represents the extension process, O represents the optimized trajectory, and B represents the behavior path. The formula states that globally (G), if the trajectory is too short (S), then in the next state (X), an extension (E) occurs, where the optimized trajectory (O) is used until (U) it's concatenated with the behavior path (B). This captures the sequential nature of extending the trajectory when it's too short for velocity planning."
  }
]