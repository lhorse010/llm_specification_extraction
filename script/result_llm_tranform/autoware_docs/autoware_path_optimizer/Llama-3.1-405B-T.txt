[
  {
    "sentence": "This package generates a trajectory that is kinematically-feasible to drive and collision-free based on the input path, drivable area.",
    "formula": "G(K ∧ C)",
    "explanation": "Here, K represents the trajectory being kinematically-feasible, and C represents the trajectory being collision-free. The formula ensures that both conditions are always met."
  },
  {
    "sentence": "Only position and orientation of trajectory are updated in this module, and velocity is just taken over from the one in the input path.",
    "formula": "G(U ∧ V)",
    "explanation": "Here, U represents the position and orientation of the trajectory being updated, and V represents the velocity being taken over from the input path. The formula ensures that both conditions are always met."
  },
  {
    "sentence": "1.make the trajectory inside the drivable area as much as possible",
    "formula": "G(D → T)",
    "explanation": "Here, D represents the drivable area, and T represents the trajectory. The formula ensures that if the trajectory is inside the drivable area, it will always be inside."
  },
  {
    "sentence": "2.insert stop point before the planned footprint will be outside the drivable area",
    "formula": "G(¬D → S)",
    "explanation": "Here, D represents the drivable area, and S represents the stop point. The formula ensures that if the planned footprint is outside the drivable area, a stop point will be inserted."
  },
  {
    "sentence": "When one of the following conditions are met, trajectory optimization will be executed.",
    "formula": "F(O1 ∨ O2 ∨ O3 ∨ O4)",
    "explanation": "Here, O1, O2, O3, and O4 represent the four conditions. The formula ensures that if any of the conditions are met, trajectory optimization will be executed eventually."
  },
  {
    "sentence": "1.Ego moves longer than replan.max_ego_moving_dist in one cycle. (default: 3.0 [m])",
    "formula": "F(E > 3.0)",
    "explanation": "Here, E represents the ego's movement distance. The formula ensures that if the ego moves longer than 3.0 meters in one cycle, trajectory optimization will be executed eventually."
  },
  {
    "sentence": "2.Trajectory's end, which is considered as the goal pose, moves longer than replan.max_goal_moving_dist in one cycle. (default: 15.0 [ms])",
    "formula": "F(G > 15.0)",
    "explanation": "Here, G represents the goal pose's movement distance. The formula ensures that if the goal pose moves longer than 15.0 meters in one cycle, trajectory optimization will be executed eventually."
  },
  {
    "sentence": "3.Time passes. (default: 1.0 [s])",
    "formula": "F(T > 1.0)",
    "explanation": "Here, T represents the time. The formula ensures that if 1.0 second passes, trajectory optimization will be executed eventually."
  },
  {
    "sentence": "4.The input path changes laterally longer than replan.max_path_shape_around_ego_lat_dist in one cycle. (default: 2.0)",
    "formula": "F(P > 2.0)",
    "explanation": "Here, P represents the input path's lateral change distance. The formula ensures that if the input path changes laterally longer than 2.0 meters in one cycle, trajectory optimization will be executed eventually."
  },
  {
    "sentence": "This module makes the trajectory kinematically-feasible and collision-free.",
    "formula": "G(K ∧ C)",
    "explanation": "Here, K represents the trajectory being kinematically-feasible, and C represents the trajectory being collision-free. The formula ensures that both conditions are always met."
  },
  {
    "sentence": "This optimization considers vehicle kinematics and collision checking with road boundary and obstacles.",
    "formula": "G(K ∧ ¬C)",
    "explanation": "Here, K represents the consideration of vehicle kinematics, and C represents collision with road boundary or obstacles. The formula ensures that kinematics is always considered and collision is always avoided."
  },
  {
    "sentence": "The trajectory just in front of the ego must not be changed a lot so that the steering wheel will be stable.",
    "formula": "G(¬∃t(T ∧ X(¬T))) → G(S)",
    "explanation": "Here, T represents a significant change in the trajectory, and S represents the stability of the steering wheel. The formula ensures that if the trajectory is not changed significantly, the steering wheel will remain stable."
  },
  {
    "sentence": "Velocity is assigned in the optimized trajectory from the velocity in the behavior path.",
    "formula": "G(V → ∃t(O ∧ V))",
    "explanation": "Here, V represents the assignment of velocity, and O represents the optimized trajectory. The formula ensures that velocity is assigned in the optimized trajectory whenever it is assigned in the behavior path."
  },
  {
    "sentence": "Optimized trajectory is too short for velocity planning, therefore extend the trajectory by concatenating the optimized trajectory and the behavior path considering drivability.",
    "formula": "G(O ∧ D → ∃t(O ∧ B ∧ D))",
    "explanation": "Here, O represents the optimized trajectory, D represents drivability, and B represents the behavior path. The formula ensures that if the optimized trajectory is too short, it is extended by concatenating it with the behavior path while considering drivability."
  },
  {
    "sentence": "Generated trajectory is checked if it is inside the drivable area or not, and if outside drivable area, output a trajectory inside drivable area with the behavior path or the previously generated trajectory.",
    "formula": "G(GT → (D → GT) ∧ (¬D → (B ∨ PT)))",
    "explanation": "Here, GT represents the generated trajectory, D represents the drivable area, B represents the behavior path, and PT represents the previously generated trajectory. The formula ensures that the generated trajectory is checked for drivability and corrected if necessary."
  },
  {
    "sentence": "1.If optimized trajectory is inside the drivable area, and the remained trajectory is inside/outside the drivable area, the output trajectory will be just concatenation of those two trajectories.",
    "formula": "G(O ∧ D ∧ (RT ∧ D ∨ RT ∧ ¬D) → (O ∧ RT))",
    "explanation": "Here, O represents the optimized trajectory, D represents the drivable area, and RT represents the remained trajectory. The formula ensures that if the optimized trajectory is inside the drivable area, the output trajectory is the concatenation of the optimized and remained trajectories."
  },
  {
    "sentence": "2.If optimized trajectory is outside the drivable area, and the remained trajectory is inside/outside the drivable area, and if the previously generated trajectory is memorized, the output trajectory will be the previously generated trajectory, where zero velocity is inserted to the point firstly going outside the drivable area; and if the previously generated trajectory is not memorized, the output trajectory will be a part of trajectory just transformed from the behavior path, where zero velocity is inserted to the point firstly going outside the drivable area.",
    "formula": "G(O ∧ ¬D ∧ (RT ∧ D ∨ RT ∧ ¬D) ∧ (PT → (PT ∧ V0)) ∧ (¬PT → (B ∧ V0)))",
    "explanation": "Here, O represents the optimized trajectory, D represents the drivable area, RT represents the remained trajectory, PT represents the previously generated trajectory, and V0 represents the insertion of zero velocity. The formula ensures that if the optimized trajectory is outside the drivable area, the output trajectory is either the previously generated trajectory or a part of the behavior path with zero velocity inserted."
  },
  {
    "sentence": "The output trajectory is memorized as a previously generated trajectory for the next cycle.",
    "formula": "G(OT → PT)",
    "explanation": "Here, OT represents the output trajectory, and PT represents the previously generated trajectory. The formula ensures that the output trajectory is memorized for the next cycle."
  },
  {
    "sentence": "In the current design, since there are some modelling errors, the constraints are considered to be soft constraints.",
    "formula": "G(E → ¬C)",
    "explanation": "Here, E represents the modelling errors, and C represents the constraints. The formula ensures that if there are modelling errors, the constraints are not strict."
  },
  {
    "sentence": "Therefore, we have to make sure that the optimized trajectory is inside the drivable area or not after optimization.",
    "formula": "G(O → (D ∨ ¬D))",
    "explanation": "Here, O represents the optimized trajectory, and D represents the drivable area. The formula ensures that the optimized trajectory is either inside or outside the drivable area after optimization."
  },
  {
    "sentence": "This parameter describes how much margin to make between the trajectory and road boundaries.",
    "formula": "G(P → Q)",
    "explanation": "Here, P represents the parameter being set, and Q represents the margin being maintained between the trajectory and road boundaries. The formula states that whenever P is true, Q is also true, globally."
  },
  {
    "sentence": "Due to the model error for optimization, the constraint such as collision-free is not fully met.",
    "formula": "¬G(C)",
    "explanation": "Here, C represents the constraint being collision-free. The formula states that it is not the case that C is always true, globally, due to the model error."
  },
  {
    "sentence": "The point on the vehicle, offset forward with this parameter from the base link` tries to follow the reference path.",
    "formula": "G(P → F(R))",
    "explanation": "Here, P represents the point on the vehicle being offset, and R represents the reference path being followed. The formula states that whenever P is true, it will eventually be the case that R is true, globally."
  },
  {
    "sentence": "if the trajectory after MPT is not robust, make mpt.weight.steer_input_weight or mpt.weight.steer_rate_weight larger, which are stability of steering wheel along the trajectory.",
    "formula": "(¬R) → (X(S ∨ T))",
    "explanation": "Here, R represents the robustness of the trajectory, S represents the steer_input_weight being larger, and T represents the steer_rate_weight being larger. The formula states that if R is not true, then it will be the case in the next step that either S or T is true."
  },
  {
    "sentence": "option.enable_skip_optimization skips MPT optimization.",
    "formula": "P → ¬O",
    "explanation": "Here, P represents the option being enabled, and O represents the MPT optimization being performed. The formula states that if P is true, then O is not true."
  },
  {
    "sentence": "option.enable_calculation_time_info enables showing each calculation time for functions and total calculation time on the terminal.",
    "formula": "P → Q",
    "explanation": "Here, P represents the option being enabled, and Q represents the calculation time information being shown. The formula states that if P is true, then Q is true."
  },
  {
    "sentence": "option.enable_outside_drivable_area_stop enables stopping just before the generated trajectory point will be outside the drivable area.",
    "formula": "P → G(¬O)",
    "explanation": "Here, P represents the option being enabled, and O represents the trajectory point being outside the drivable area. The formula states that if P is true, then it will always be the case that O is not true, globally."
  },
  {
    "sentence": "2.modify mpt.kinematics.optimization_center_offset",
    "formula": "X(M)",
    "explanation": "Here, M represents the modification being made. The formula states that M will be true in the next step."
  }
]